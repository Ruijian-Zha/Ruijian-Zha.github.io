(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{510:function(t,o,e){"use strict";e.r(o);var r=e(4),l=Object(r.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"dp理论讲义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dp理论讲义"}},[t._v("#")]),t._v(" dp理论讲义")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("内容来源 ：bilibili 花花酱Leetcode 🎉")])]),t._v(" "),e("p",[e("strong",[t._v("DP:")]),t._v(" Dynamic Programming")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("optimal substructure")]),t._v(" "),e("ul",[e("li",[t._v("将主问题分成子问题，找到每个子问题的最优解然后拼在一起")])])]),t._v(" "),e("li",[e("strong",[t._v("overlapping sub-problems")]),t._v(" "),e("ul",[e("li",[t._v("子问题 only compute once and store the solution for future use")]),t._v(" "),e("li",[t._v("reduce time complexity (exponential to polynomial)")]),t._v(" "),e("li",[t._v('if sub-problem don\'t overlap -> "divide and conquer"')])])]),t._v(" "),e("li",[e("strong",[t._v("No-after effect")]),t._v(" "),e("ul",[e("li",[t._v("the optimal solution of a subproblem will not change when it war used to solve a bigger problem optimally")])])])]),t._v(" "),e("p",[e("strong",[t._v("结构理解")]),t._v("："),e("br"),t._v(" "),e("strong",[t._v("Top-down")]),t._v(": recursion with memoization "),e("br"),t._v(" "),e("strong",[t._v("Bottom-up")]),t._v(": DP")]),t._v(" "),e("p",[e("strong",[t._v("Leetcode")]),t._v(":\n"),e("a",{attrs:{href:"https://demo.codimd.org/s/Hy35wVZOw",target:"_blank",rel:"noopener noreferrer"}},[t._v("Leetcode 70. 爬楼梯(easy)"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("递归 --\x3e 记忆化递归 --\x3e dp")])])])}),[],!1,null,null,null);o.default=l.exports}}]);