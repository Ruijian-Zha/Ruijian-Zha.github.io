(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{526:function(e,t,a){"use strict";a.r(t);var i=a(4),v=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"dfs和bfs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dfs和bfs"}},[e._v("#")]),e._v(" DFS和BFS")]),e._v(" "),a("h2",{attrs:{id:"对比dfs和bfs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比dfs和bfs"}},[e._v("#")]),e._v(" 对比DFS和BFS")]),e._v(" "),a("p",[e._v("BFS")]),e._v(" "),a("ul",[a("li",[e._v("空间是指数级别的，大")]),e._v(" "),a("li",[e._v("不会有爆栈风险")]),e._v(" "),a("li",[e._v("可以求最短，最小")])]),e._v(" "),a("p",[e._v("DFS")]),e._v(" "),a("ul",[a("li",[e._v("空间和深度成正比，小！")]),e._v(" "),a("li",[e._v("有爆栈的风险，比如深度最坏可能有1e5层，会爆栈（C++一般4M）；层信息都放在栈空间里")]),e._v(" "),a("li",[e._v("不能搜最短、最小")])]),e._v(" "),a("h2",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[e._v("#")]),e._v(" 注意事项")]),e._v(" "),a("ul",[a("li",[e._v("判断当前节点、层是否已得到最终解")]),e._v(" "),a("li",[e._v("判断是否可以剪枝")]),e._v(" "),a("li",[e._v("防止循环遍历问题（比如存在环路，要退出）")]),e._v(" "),a("li",[e._v("遍历顺序如何选择（比如是弧头到弧尾还是弧尾到弧头）")])]),e._v(" "),a("h2",{attrs:{id:"flood-fill算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flood-fill算法"}},[e._v("#")]),e._v(" flood fill算法")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("LeetCode 733. Flood Fill (easy)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 200. Number of Islands (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 542. 01 Matrix (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 695. Max Area of Island (medium)")])])]),e._v(" "),a("h2",{attrs:{id:"二分图判定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二分图判定"}},[e._v("#")]),e._v(" 二分图判定")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/algorithm/graph/二分图.html"}},[e._v("二分图判定")])],1),e._v(" "),a("h2",{attrs:{id:"拓扑排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拓扑排序"}},[e._v("#")]),e._v(" 拓扑排序")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/algorithm/graph/拓扑排序.html"}},[e._v("拓扑排序")])],1),e._v(" "),a("h2",{attrs:{id:"习题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#习题"}},[e._v("#")]),e._v(" 习题")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("LeetCode 111. Minimum Depth of Binary Tree (easy)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 279. Perfect Squares (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 130. Surrounded Regions (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 543. Diameter of Binary Tree (easy)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 127. Word Ladder (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 542. 01 Matrix (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 695. Max Area of Island (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 886. Possible Bipartition (medium)")])]),e._v(" "),a("li",[a("p",[e._v("LeetCode 1377. Frog Position After T Seconds (hard)")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);